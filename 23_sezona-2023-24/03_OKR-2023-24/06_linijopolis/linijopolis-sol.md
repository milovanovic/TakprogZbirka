---
title: Линијополис - опис решења
---

# Линијополис
Аутор: Александар Вишњић
Текст и тест примери: Андреј Ивашковић
Анализа решења: Александар Вишњић
Тестирање: Марко Шишовић

## Решење када $M\leq 10, N\leq 100$
За сваки подскуп аутобуса проверавамо да ли могу прећи целу трасу. Када се одлучимо за неки такав, пуштамо аутобусе по принципу "један по један". Сваком је циљ да коришћењем што мање додатних битова стигне до краја. Уколико му је то потребно, битове ће узимати у најкаснијем могућем тренутку. Ако је могуће испунити циљ, он неће узурпирати остале аутобусе. Временска сложеност је $O(2^M \cdot M\cdot N)$.

## Решење када $N,M\leq 10^4$
Надовезујемо се на претходни подзадатак. Уместо разматрања сваког подскупа, можемо уочити то да аутобуси са већом почетном количином битова имају већу шансу да стигну до краја и штеде више битова. Зато их сортирамо по том параметру и пуштамо их редом од највећег ка најмањем. Приметимо да не знамо унапред величину групе аутобуса, већ је одрећујемо накнадно након неуспешне трасе (или након што сви аутобуси стигну до краја). Највећа група ће управо бити последња "тренутна" група коју је описани алгоритам нашао. Временска сложеност је $O(M\log M + M\cdot N)$.

## Решење када $N,M\leq 10^5$
Оптимално је одредити неколико аутобуса са највећом почетном количином битова. Стога вршимо бинарну претрагу по вредности решења. Претпоставимо да смо се одлучили за групу од $K$ аутобуса. Њих паралелно пуштамо да путују заједно кроз сваку станицу. Када доћу до станице употребљавају све доступне битове. Приоритет има аутобус који је "најпразнији". Промене је могуће симулирати преко **min heap** (priority queue) структуре. 

У њој памтимо количине битова, као и број аутобуса који имају исту. Уколико имамо довољно битова на располагању, десиће се да "спојимо" две најниже вредности, чиме се величина структуре смањује за један. Приликом једне овакве операције, смањивање се може десити произвољан број пута, али додавање се дешава највише двапут (приликом дељења недовољног броја битова са остатком). Како у структуру не можемо одузети више него што смо додали, сложеност провере је $O((N+M)\log M$.

Због употребе бинарне претраге, укупна временска сложеност је $O((N+M)\log^2M)$.

## Главно решење
Уместо *min heap* структуре користимо **stack**. Провера постаје линеарна, а укупна сложеност је $O((N+M)\log M$.
